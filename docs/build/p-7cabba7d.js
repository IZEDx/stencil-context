const t=(...n)=>t.debug&&console.log(...n);t.debug=!1;const n=t,e=()=>{};function r(t,r,o){const i=t[r]||e;t[r]=async function(...t){n(r,this);const e=await o(this);let s=await i.apply(this,t);return e instanceof Function&&await e(this),s}}function o(t){var n;const e=null===(n=t)||void 0===n?void 0:n.el;if(e instanceof Object&&"function"==typeof e.forceUpdate)return e;throw new a(`Property 'el' required on ${t}`)}const i=Symbol.for("stencil-quantum-providers");class s{constructor(t,n){this.key=t,this.value=n,this.listeners=[],this.hooks=new Map,this.retrieve=this.retrieve.bind(this),this.provide=this.provide.bind(this),this.listen=this.listen.bind(this)}retrieve(){return this.value}provide(t){return n("PROVIDING",t,"to",this.listeners),this.value=t,this.listeners.forEach(n=>n(t)),this}update(t){return this.provide(t(this.retrieve()))}listen(t,e=!0){return n("LISTEN",e,this,t),this.listeners=[...this.listeners,t],e&&t(this.value),()=>{this.listeners=this.listeners.filter(n=>n!==t)}}attach(t,e){n("Add Provider",t,this);const r=s.getAttached(t);return r.includes(this)||r.push(this),n("Total Providers",t,r),e?this:this.hook(t)}isHooked(t){return this.hooks.has(t)}hook(t){return n("Hook Provider",t,this),this.hooks.set(t,this.listen(()=>t.forceUpdate())),this}unhook(t){return n("Unhook Provider",t,this),this.isHooked(t)&&(this.hooks.get(t)(),this.hooks.delete(t)),this}static find(t,e){var r,o,i,c;n("Searching Provider",e,t);const h=s.getAttached(t).filter(t=>t.key===e);if(h.length>1)throw new a(`Found multiple "${String(e)}" providers on the same object!`);if(1===h.length)return h[0];let u=null!=(i=null!=(r=t.parentElement)?r:null===(o=t.shadowRoot)||void 0===o?void 0:o.host)?i:null===(c=t.parentNode)||void 0===c?void 0:c.host;if(!u)throw new a(`No provider in hierarchy found that matches "${String(e)}"!`);return s.find(u,e).attach(t,!0)}static create(t,e,r){return n("Create Provider",t,e,r),new s(e,r).attach(t)}static getAttached(t){return t[i]instanceof Array||(t[i]=[]),t[i]}}const c=Symbol.for("stencil-quantum-error");class a extends Error{constructor(t,n){super(t instanceof Error?t.message:t),this.target=n,t instanceof Error&&Object.assign(this,t)}}function h(t,n){const e=new a(n,t);console.error(e);try{s.find(t,c).provide(e)}catch(r){throw e}}function u(){return function(t,n){const e=new s(c,t[n]);r(t,"componentWillLoad",t=>{const n=o(t);try{e.attach(n),e.hook(n)}catch(r){h(n,r)}}),delete t[n]&&Object.defineProperty(t,n,{get:e.retrieve,set:e.provide,enumerable:!0,configurable:!0})}}function l(t){return function(n,e){const i=new s(t=t||e,n[e]);r(n,"componentWillLoad",t=>{const n=o(t);try{i.attach(n),i.hook(n)}catch(e){h(n,e)}}),delete n[e]&&Object.defineProperty(n,e,{get:i.retrieve,set:i.provide,enumerable:!0,configurable:!0})}}function d(t){return function(n,e){let i,c;t=t||e,r(n,"componentWillLoad",n=>{const e=o(n);try{(i=s.find(e,t)).hook(e)}catch(r){}return()=>{try{i&&i.unhook(e),(i=s.find(e,t)).hook(e)}catch(r){h(e,r)}}}),delete n[e]&&Object.defineProperty(n,e,{get:()=>i&&i.retrieve()||c,set:t=>c=t,enumerable:!0,configurable:!0})}}function f(t){return function(n,e,i){const c=i.value;return r(n,"componentWillLoad",n=>{const r=o(n);let i,a=()=>{};t&&(i=s.create(r,e,void 0));const u=()=>{const o=s.find(r,null!=t?t:e);a=o.listen(t=>{try{const e=c.apply(n,[t]);i&&i.provide(e)}catch(e){h(r,e)}})};try{u()}catch(l){}return()=>{a();try{u()}catch(l){h(r,l)}}}),i}}function v(t,e,i,c=100){return function(t,e,i,c,a=100){return function(u,l){const d={proto:u,propertyName:l,value:u[l],path:e,fns:c,query:w(e)};d.fns.init&&d.fns.init(d),r(u,"componentWillLoad",async e=>{d.obj=e,d.el=o(d.obj);try{d.fns.onComponent&&await d.fns.onComponent(d)}catch(r){h(d.el,r)}return()=>{try{let e;s.find(d.el,t).listen(async t=>{try{d.axios=t,d.fns&&d.fns.onAxios&&await d.fns.onAxios(d)}catch(r){h(d.el,r)}}),void 0!==i&&s.find(d.el,i).listen(async t=>{n("Pre onParams",t),d.params=t,d.query=w(d.path,d.params),e&&clearTimeout(e),e=setTimeout(async()=>{var t,n,e;try{await(null===(e=null===(t=d.fns)||void 0===t?void 0:(n=t).onParams)||void 0===e?void 0:e.call(n,d))}catch(r){h(d.el,r)}},a)})}catch(r){h(d.el,r)}}}),delete u[l]&&Object.defineProperty(u,l,{get:()=>d.fns&&d.fns.getValue(d),set:t=>d.fns&&d.fns.setValue(t,d),enumerable:!0,configurable:!0})}}(t,e,i,{onAxios(t){n("GET onAxios",t.params),i&&!t.params||t.fns.send(t)},onParams(t){n("GET onParams",t.params,t.query),t.axios&&t.fns.send(t)},async send(t){n("GET send",t);const e=await t.axios.get(t.query.path,{params:t.query.params});t.value=e.data,t.el.forceUpdate()},setValue(t,n){n.value=t,n.el&&n.el.forceUpdate()},getValue:t=>t.value},c)}const p=[{replace:t=>`{${t}}`,with:t=>`${t}`},{replace:t=>`/\\:${t}$`,with:t=>`/${t}`},{replace:t=>`/\\:${t}/`,with:t=>`/${t}/`}],y=t=>`${t}`;function w(t,e){let r=t,o={};if(e)for(let[i,s]of Object.entries(e)){const t=r;(r=p.reduce((t,e)=>{var r,o,c;const a=e.replace(i);return n("------ Checking ",t,"with",a),t.match(new RegExp(a,"g"))?t.replace(new RegExp(a,"g"),escape(null!=(c=null===(o=(r=e).with)||void 0===o?void 0:o.call(r,s))?c:y(s))):t},r))===t&&(o[i]=s)}return{path:r,params:o}}export{d as C,v as G,l as P,f as W,u as a,s as b,n as l,h as t};